use std;

// Problem 001
// If we list all the natural numbers below 10 that are multiples of 3 or 5,
// we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all
// the multiples of 3 or 5 below 1000.

pub fn prob001(n: i32) -> i32{
	let mut result = 0;
	for i in 1..n {
		if i % 3 == 0 || i % 5 == 0 {
			result += i;
		}
	}
	return result;
}


#[test]
fn test001() {
	assert_eq!(prob001(10), 23);
}


// Problem 002
// Each new term in the Fibonacci sequence is generated by adding the previous
// two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed
// four million, find the sum of the even-valued terms.

pub fn prob002(n: i32) -> i32{
	let mut result = 0;
	let (mut prev, mut cur) = (1, 2);
	while cur < n {
		if cur % 2 == 0 {
			result += cur;
		}
		cur = prev + cur;
		prev = cur - prev;
	}
	return result;
}


#[test]
fn test002() {
	assert_eq!(prob002(10), 10);
}

// Problem 003
// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143?

pub fn prob003(n: i64) -> i64 {
	let mut primes = Vec::new();
	let mut remains = n;
	let mut p = 2;
	while p <= remains {
		let mut is_prime = true;
		for p2 in &primes {
			if p % p2 == 0 {
				is_prime = false;
				break;
			}
		}
		if is_prime {
			primes.push(p);
			while remains % p == 0 {
				remains /= p;
			}
		}
		p += 1;
	}
	return primes[primes.len()-1];
}


#[test]
fn test003() {
	assert_eq!(prob003(13195), 29);
}

// Probelem 004
// A palindromic number reads the same both ways. The largest palindrome made
// from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.
fn reverse(n:i32) -> i32 {
	let mut result = 0;
	let mut m = n;
	while m > 0 {
		result *= 10;
		result += m % 10;
		m /= 10;
	}
	return result;
}
pub fn prob004(lo: i32, hi: i32) -> i32 {
	let mut result = 0;
	for a in lo..=hi {
		for b in a..=hi {
			let m = a*b;
			if m == reverse(m) {
				result = std::cmp::max(result, a*b);
			}
		}
	}
	return result;
}


#[test]
fn test004() {
	assert_eq!(prob004(10, 99), 9009);
}

// Probelem 005
// A palindromic number reads the same both ways. The largest palindrome made
// from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.

fn euclid(m: u64, n: u64) -> u64 {
	match m.cmp(&n) {
		std::cmp::Ordering::Equal => m,
		std::cmp::Ordering::Less => euclid(m, n-m*std::cmp::max(n/m-1, 1)),
		std::cmp::Ordering::Greater => euclid(m-n*std::cmp::max(m/n-1, 1), n),
	}
}

pub fn prob005(n: u64) -> u64 {
	let mut result = 1;

	for i in 2..=n {
		result = result * i / euclid(result, i);
	}
	return result;
}


#[test]
fn test005() {
	assert_eq!(prob005(10), 2520);
}


// Problem 6
// The sum of the squares of the first ten natural numbers is,
// 12+22+...+102=385
// The square of the sum of the first ten natural numbers is,
// (1+2+...+10)2=552=3025
// Hence the difference between the sum of the squares of the first ten natural
// numbers and the square of the sum is 3025−385=2640.
// Find the difference between the sum of the squares of the first one hundred
// natural numbers and the square of the sum.


pub fn prob006(n: u64) -> u64 {
	let mut result = 1;

	for i in 2..=n {
		result = result * i / euclid(result, i);
	}
	return result;
}


#[test]
fn test006() {
	assert_eq!(prob006(10), 2520);
}

